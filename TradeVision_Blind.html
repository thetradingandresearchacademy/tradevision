<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TradeVision | V3 Tank Parser</title>
    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        :root { --bg: #0d0d0d; --panel: #1a1a1a; --text: #e0e0e0; --gold: #D4AF37; --err: #ff4d4d; --success: #00cc66; }
        body { margin: 0; background: var(--bg); color: var(--text); font-family: 'Segoe UI', monospace; height: 100vh; display: flex; overflow: hidden; }

        /* SIDEBAR */
        .sidebar { width: 350px; background: var(--panel); border-right: 1px solid #333; padding: 20px; display: flex; flex-direction: column; gap: 15px; }
        .logo { font-size: 18px; font-weight: bold; color: white; border-bottom: 1px solid #333; padding-bottom: 10px; }
        .logo span { color: var(--gold); }

        .drop-zone {
            border: 2px dashed #555; border-radius: 6px; padding: 40px 20px; text-align: center; cursor: pointer;
            transition: 0.2s; position: relative; background: #111; color: #888; font-size: 13px;
        }
        .drop-zone:hover { border-color: var(--gold); color: #fff; background: #222; }
        .drop-zone input { position: absolute; top:0; left:0; width:100%; height:100%; opacity:0; cursor: pointer; }

        /* DEBUG CONSOLE (CRITICAL) */
        .console {
            background: #000; border: 1px solid #333; flex-grow: 1; overflow-y: auto; 
            font-size: 11px; padding: 10px; font-family: 'Consolas', monospace; color: #ccc; white-space: pre-wrap;
        }
        .log-info { color: #00ccff; }
        .log-success { color: var(--success); }
        .log-err { color: var(--err); background: rgba(255,0,0,0.1); }
        .log-warn { color: orange; }

        /* CHART */
        #chart { flex-grow: 1; position: relative; }
        .watermark { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #333; font-size: 24px; font-weight: bold; pointer-events: none; }
    </style>
</head>
<body>

<div class="sidebar">
    <div class="logo">TradeVision <span>TANK V3</span></div>
    
    <div class="drop-zone" id="dropZone">
        <div>ðŸ“‚ DRAG CLEANED FILE HERE</div>
        <div style="margin-top:5px; font-size:10px;">(Accepts CSV / Excel-CSV)</div>
        <input type="file" id="fileInput" accept=".csv, .txt">
    </div>

    <div>System Log:</div>
    <div class="console" id="console">
        <div class="log-info">> Tank Engine Ready.</div>
        <div class="log-info">> Waiting for file...</div>
    </div>
</div>

<div id="chart">
    <div class="watermark" id="watermark">NO DATA LOADED</div>
</div>

<script>
    // --- UTILS: LOGGER ---
    const consoleDiv = document.getElementById('console');
    function log(msg, type='info') {
        const div = document.createElement('div');
        div.innerText = `> ${msg}`;
        if(type==='err') div.className = 'log-err';
        if(type==='success') div.className = 'log-success';
        if(type==='warn') div.className = 'log-warn';
        if(type==='info') div.className = 'log-info';
        consoleDiv.appendChild(div);
        consoleDiv.scrollTop = consoleDiv.scrollHeight;
    }

    // --- CHART SETUP ---
    const chart = LightweightCharts.createChart(document.getElementById('chart'), {
        layout: { background: { color: '#0d0d0d' }, textColor: '#888' },
        grid: { vertLines: { color: '#222' }, horzLines: { color: '#222' } },
        crosshair: { mode: 0 },
        timeScale: { borderColor: '#333', timeVisible: true }
    });
    const candleSeries = chart.addCandlestickSeries({ upColor: '#089981', downColor: '#f23645', borderVisible: false });
    const simSeries = chart.addCandlestickSeries({ upColor: '#0ff', downColor: '#f0f', borderVisible: true, wickUpColor:'#0ff', wickDownColor:'#f0f' });

    window.addEventListener('resize', () => {
        chart.applyOptions({ width: document.getElementById('chart').clientWidth, height: document.getElementById('chart').clientHeight });
    });


    // --- THE "TANK" PARSER ---
    document.getElementById('fileInput').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if(!file) return;

        log(`Reading: ${file.name}...`, 'info');
        
        const reader = new FileReader();
        reader.onload = (evt) => {
            const text = evt.target.result;
            try {
                processCSV(text);
            } catch(e) {
                log(`CRITICAL ERROR: ${e.message}`, 'err');
            }
        };
        reader.readAsText(file);
    });

    function processCSV(rawText) {
        const lines = rawText.trim().split('\n');
        log(`File has ${lines.length} lines.`, 'info');

        if(lines.length < 2) throw new Error("File is empty or too short.");

        // 1. FIND HEADER
        let headerIdx = -1;
        let map = { t: -1, o: -1, h: -1, l: -1, c: -1 };

        // Look at first 10 lines for header candidates
        for(let i=0; i<Math.min(lines.length, 10); i++) {
            const row = lines[i].toLowerCase();
            // Fuzzy match: must have 'date' and 'close'
            if(row.includes('date') && row.includes('close')) {
                headerIdx = i;
                log(`Header found at line ${i+1}: "${lines[i]}"`, 'success');
                
                // Clean header for mapping (remove special chars)
                const cleanHeader = row.replace(/[^a-z0-9,]/g, ""); 
                const cols = cleanHeader.split(',');
                
                cols.forEach((col, idx) => {
                    if(col.includes('date') || col.includes('time')) map.t = idx;
                    if(col.includes('open')) map.o = idx;
                    if(col.includes('high')) map.h = idx;
                    if(col.includes('low')) map.l = idx;
                    if(col.includes('close')) map.c = idx;
                });
                break;
            }
        }

        if(headerIdx === -1) {
            log("Could not find standard headers. Attempting blind scan...", 'warn');
            // If failed, assume standard [Date, Open, High, Low, Close] (common export format)
            map = { t:0, o:1, h:2, l:3, c:4 };
            headerIdx = 0; 
        }

        log(`Mapping: T[${map.t}] O[${map.o}] H[${map.h}] L[${map.l}] C[${map.c}]`, 'info');

        // 2. PARSE DATA
        const data = [];
        let errors = 0;

        for(let i = headerIdx + 1; i < lines.length; i++) {
            const line = lines[i].trim();
            if(!line) continue;

            // SMART SPLIT: Handle "1,200" quoted numbers
            // Regex splits by comma ONLY if not inside quotes
            const parts = line.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);

            if(parts.length < 5) continue;

            try {
                // Time Parsing
                let tStr = parts[map.t].replace(/["']/g, '').trim(); 
                let dateVal;

                if(tStr.includes('-') || tStr.includes('/')) {
                     // String Date
                    dateVal = new Date(tStr).getTime() / 1000;
                } else {
                    // Unix or Serial
                    dateVal = parseFloat(tStr);
                    if(dateVal > 10000000000) dateVal /= 1000; 
                }
                
                if(isNaN(dateVal)) continue;

                // Price Parsing (Strip everything except 0-9 and .)
                const parsePrice = (raw) => {
                    if(!raw) return NaN;
                    // Remove quotes and commas
                    const clean = raw.replace(/["',]/g, '');
                    return parseFloat(clean);
                };

                const o = parsePrice(parts[map.o]);
                const h = parsePrice(parts[map.h]);
                const l = parsePrice(parts[map.l]);
                const c = parsePrice(parts[map.c]);

                if(!isNaN(c)) {
                    data.push({ time: dateVal, open: o, high: h, low: l, close: c });
                }

            } catch(e) {
                errors++;
            }
        }

        if(data.length === 0) throw new Error("Parsed 0 valid rows. Check console.");
        
        // Sort
        data.sort((a,b) => a.time - b.time);
        
        log(`Successfully parsed ${data.length} candles!`, 'success');
        log(`Range: ${new Date(data[0].time*1000).toLocaleDateString()} to ${new Date(data[data.length-1].time*1000).toLocaleDateString()}`, 'info');

        // RENDER
        candleSeries.setData(data);
        chart.timeScale().fitContent();
        document.getElementById('watermark').style.display = 'none';

        // AUTO-SIMULATE
        generateSim(data);
    }

    function generateSim(data) {
        log("Generating 6-Month Projection...", 'info');
        const last = data[data.length-1];
        const simData = [];
        
        // Calculate Interval (Daily vs Weekly)
        const t1 = data[data.length-1].time;
        const t2 = data[data.length-2].time;
        const interval = t1 - t2;

        // Calculate Volatility (ATR)
        const lookback = data.slice(-20);
        let trSum = 0;
        lookback.forEach(d => trSum += (d.high - d.low));
        const atr = trSum / 20;

        let current = { ...last };

        for(let i=0; i<30; i++) {
            // Random Walk
            const shock = (Math.random() - 0.5) * atr; // Neutral bias
            
            const open = current.close;
            const close = open + shock;
            const high = Math.max(open, close) + (Math.random() * atr * 0.5);
            const low = Math.min(open, close) - (Math.random() * atr * 0.5);
            
            const nextTime = current.time + interval;
            current = { time: nextTime, open, high, low, close };
            simData.push(current);
        }

        simSeries.setData(simData);
        log("Projection Active (Cyan).", 'success');
    }
</script>
</body>
</html>
