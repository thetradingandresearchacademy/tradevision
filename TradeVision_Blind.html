<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TradeVision | Gold Master</title>
    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        body { margin: 0; background: #000; color: #ccc; font-family: sans-serif; height: 100vh; display: flex; overflow: hidden; }
        
        .sidebar { width: 300px; background: #111; border-right: 1px solid #333; display: flex; flex-direction: column; padding: 20px; }
        .main { flex-grow: 1; position: relative; }

        .box { border: 2px dashed #444; padding: 40px 20px; text-align: center; border-radius: 8px; cursor: pointer; transition: 0.2s; background: #0a0a0a; }
        .box:hover { border-color: #D4AF37; color: white; background: #1a1a1a; }
        .box input { display: none; }

        .log { margin-top: 20px; font-family: monospace; font-size: 11px; color: #666; overflow-y: auto; flex-grow: 1; border-top: 1px solid #222; padding-top: 10px; }
        .log div { margin-bottom: 4px; }
        .err { color: #f44; }
        .success { color: #0f0; }

        #chart { width: 100%; height: 100%; }
        .watermark { position: absolute; top:50%; left:50%; transform:translate(-50%,-50%); color:#222; font-size: 24px; font-weight:bold; pointer-events:none; }
        
        /* Analysis Stats */
        .stats { margin-top: 20px; display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .stat-box { background: #222; padding: 10px; border-radius: 4px; }
        .label { font-size: 10px; color: #888; text-transform: uppercase; }
        .val { font-size: 14px; font-weight: bold; color: white; margin-top: 2px; }
    </style>
</head>
<body>

<div class="sidebar">
    <h2 style="margin:0 0 20px 0; color:#fff;">TradeVision <span style="color:#D4AF37">GOLD</span></h2>
    
    <label class="box">
        ðŸ“‚ LOAD DATA
        <input type="file" id="fileInput" accept=".csv, .txt">
    </label>

    <div class="stats">
        <div class="stat-box">
            <div class="label">Structure</div>
            <div class="val" id="regime">---</div>
        </div>
        <div class="stat-box">
            <div class="label">Volatility</div>
            <div class="val" id="vol">---</div>
        </div>
    </div>

    <div class="log" id="log">
        <div>> System Ready.</div>
    </div>
</div>

<div class="main">
    <div id="chart"></div>
    <div class="watermark" id="msg">NO DATA</div>
</div>

<script>
    // 1. SETUP CHART
    const chart = LightweightCharts.createChart(document.getElementById('chart'), {
        layout: { background: { color: '#000' }, textColor: '#666' },
        grid: { vertLines: { color: '#151515' }, horzLines: { color: '#151515' } },
        timeScale: { borderColor: '#333' }
    });
    const mainSeries = chart.addCandlestickSeries({ upColor: '#089981', downColor: '#f23645', borderVisible: false });
    const simSeries = chart.addCandlestickSeries({ upColor: '#0ff', downColor: '#f0f', borderVisible: true, wickUpColor:'#0ff', wickDownColor:'#f0f' });

    window.addEventListener('resize', () => {
        chart.applyOptions({ width: document.getElementById('chart').clientWidth, height: document.getElementById('chart').clientHeight });
    });

    // 2. LOGGING
    const logDiv = document.getElementById('log');
    function log(msg, type='') {
        const d = document.createElement('div');
        d.innerText = `> ${msg}`;
        if(type=='err') d.className='err';
        if(type=='success') d.className='success';
        logDiv.appendChild(d);
        logDiv.scrollTop = logDiv.scrollHeight;
    }

    // 3. PARSING LOGIC (THE FIX)
    document.getElementById('fileInput').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if(!file) return;
        log(`Reading ${file.name}...`);

        const reader = new FileReader();
        reader.onload = (evt) => {
            const text = evt.target.result;
            try {
                // Determine headers
                const lines = text.trim().split('\n');
                let startRow = 1; 
                let map = {t:0, o:1, h:2, l:3, c:4}; // Default Assumption

                // Scan for header row
                for(let i=0; i<Math.min(lines.length, 10); i++) {
                    const row = lines[i].toLowerCase();
                    if(row.includes('date') && row.includes('close')) {
                        startRow = i + 1;
                        log(`Header detected at line ${i+1}`, 'success');
                        
                        // Map columns
                        const cols = row.split(',');
                        cols.forEach((c, idx) => {
                            if(c.includes('date')) map.t = idx;
                            if(c.includes('open')) map.o = idx;
                            if(c.includes('high')) map.h = idx;
                            if(c.includes('low')) map.l = idx;
                            if(c.includes('close')) map.c = idx;
                        });
                        break;
                    }
                }

                const data = [];
                for(let i=startRow; i<lines.length; i++) {
                    const line = lines[i].trim();
                    if(!line) continue;

                    // SIMPLE SPLIT - We only care about the first 5 columns
                    const parts = line.split(',');
                    
                    if(parts.length < 5) continue;

                    // Parse Date
                    let tRaw = parts[map.t];
                    let time;
                    if(tRaw.includes('-') || tRaw.includes('/')) {
                        time = new Date(tRaw).getTime() / 1000;
                    } else {
                        time = parseFloat(tRaw); // Unix or Serial
                        if(time > 10000000000) time /= 1000;
                    }

                    // Parse Prices (Strip quotes if any)
                    const clean = (val) => parseFloat(val.replace(/['"]/g, ''));
                    const o = clean(parts[map.o]);
                    const h = clean(parts[map.h]);
                    const l = clean(parts[map.l]);
                    const c = clean(parts[map.c]);

                    if(!isNaN(time) && !isNaN(c)) {
                        data.push({ time, open:o, high:h, low:l, close:c });
                    }
                }

                if(data.length === 0) throw new Error("No data found");

                data.sort((a,b)=>a.time-b.time);
                log(`Parsed ${data.length} candles.`, 'success');

                // Render
                mainSeries.setData(data);
                document.getElementById('msg').style.display='none';
                
                // Run Logic
                analyzeAndSimulate(data);
                chart.timeScale().fitContent();

            } catch(e) {
                log(e.message, 'err');
            }
        };
        reader.readAsText(file);
    });

    // 4. SIMULATION LOGIC
    function analyzeAndSimulate(data) {
        // Analysis
        const lookback = data.slice(-20);
        const first = lookback[0].close;
        const last = lookback[lookback.length-1].close;
        
        let volSum = 0;
        lookback.forEach(d => volSum += (d.high-d.low));
        const atr = volSum / 20;
        
        const change = ((last - first) / first) * 100;
        const volPct = (atr / last) * 100;

        let regime = "RANGE";
        let color = "#fff";
        if(change > 3) { regime="BULLISH"; color="#089981"; }
        if(change < -3) { regime="BEARISH"; color="#f23645"; }
        
        document.getElementById('regime').innerText = regime;
        document.getElementById('regime').style.color = color;
        document.getElementById('vol').innerText = volPct.toFixed(2) + "%";

        // Simulation
        const simData = [];
        let current = { ...data[data.length-1] };
        const interval = data[1].time - data[0].time;
        
        // Drift
        let drift = 0;
        if(regime=="BULLISH") drift = atr * 0.2;
        if(regime=="BEARISH") drift = -atr * 0.2;

        for(let i=0; i<26; i++) {
            const shock = (Math.random()-0.5) * atr;
            const open = current.close;
            const close = open + drift + shock;
            const high = Math.max(open, close) + (Math.random() * atr * 0.3);
            const low = Math.min(open, close) - (Math.random() * atr * 0.3);
            
            const nextTime = current.time + interval;
            current = { time:nextTime, open, high, low, close };
            simData.push(current);
        }
        simSeries.setData(simData);
    }
</script>
</body>
</html>
