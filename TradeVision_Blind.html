<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TradeVision | Blind Data Sniffer</title>
    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
    <style>
        :root { --bg: #000; --panel: #111; --text: #ccc; --gold: #D4AF37; --cyan: #0ff; }
        body { margin: 0; background: var(--bg); color: var(--text); font-family: monospace; height: 100vh; display: flex; overflow: hidden; }

        /* SIDEBAR */
        .sidebar { width: 300px; background: var(--panel); border-right: 1px solid #333; padding: 20px; display: flex; flex-direction: column; gap: 15px; }
        .logo { font-size: 16px; font-weight: bold; color: white; border-bottom: 1px solid #333; padding-bottom: 10px; }
        .logo span { color: var(--gold); }

        .drop-area {
            border: 2px dashed #444; border-radius: 4px; padding: 40px 20px; text-align: center;
            cursor: pointer; transition: 0.2s; position: relative; background: #0a0a0a; color: #666;
        }
        .drop-area:hover { border-color: var(--gold); color: #fff; background: #1a1600; }
        .drop-area input { position: absolute; top:0; left:0; width:100%; height:100%; opacity:0; cursor: pointer; }

        /* CONSOLE */
        .console {
            background: #000; border: 1px solid #333; flex-grow: 1; overflow-y: auto; 
            font-size: 11px; padding: 10px; font-family: 'Consolas', monospace; color: #0f0; white-space: pre-wrap;
        }
        .log-err { color: #f44; }
        .log-data { color: #888; }

        /* CHART */
        #chart { flex-grow: 1; position: relative; }
        .watermark { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #222; font-size: 20px; pointer-events: none; }
    </style>
</head>
<body>

<div class="sidebar">
    <div class="logo">TradeVision <span>BLIND-SNIFFER</span></div>
    
    <div class="drop-area" id="dropZone">
        <div>ðŸ“‚ DRAG FILE HERE</div>
        <div style="margin-top:5px; font-size:10px;">(Ignores Headers, Scans Data)</div>
        <input type="file" id="fileInput" accept=".csv, .txt">
    </div>

    <div>Analysis Log:</div>
    <div class="console" id="console">
        <div>> Engine Ready.</div>
        <div>> Awaiting file...</div>
    </div>
</div>

<div id="chart">
    <div class="watermark" id="watermark">NO DATA</div>
</div>

<script>
    // --- 1. THE BLIND SNIFFER ENGINE ---
    // Does not read headers. Looks for data patterns.
    class BlindParser {
        static parse(text) {
            const lines = text.trim().split('\n');
            if(lines.length < 2) throw new Error("File empty");

            // Step 1: Find the First Data Row
            // We skip the first few rows if they contain text (headers)
            let dataStartRow = 0;
            let colMap = null;

            for(let i=0; i<Math.min(lines.length, 10); i++) {
                const row = lines[i];
                // Regex to handle quoted commas: "1,200"
                const parts = row.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
                
                // Heuristic: Does this row look like data?
                // We need at least 5 columns usually (Date, O, H, L, C)
                if(parts.length < 5) continue;

                // Check types
                const potentialMap = this.sniffRow(parts);
                if(potentialMap) {
                    dataStartRow = i;
                    colMap = potentialMap;
                    break;
                }
            }

            if(!colMap) throw new Error("Could not identify Date/Price columns automatically.");

            // Step 2: Parse using the map
            const data = [];
            for(let i = dataStartRow; i < lines.length; i++) {
                const row = lines[i].trim();
                if(!row) continue;
                
                const parts = row.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
                if(parts.length <= Math.max(colMap.c, colMap.t)) continue;

                try {
                    // Clean & Parse Date
                    let tRaw = parts[colMap.t].replace(/["']/g, '').trim();
                    let timeVal;
                    
                    // Is it YYYY-MM-DD?
                    if(tRaw.includes('-') || tRaw.includes('/')) {
                        timeVal = new Date(tRaw).getTime() / 1000;
                    } else {
                        // Is it Unix?
                        timeVal = parseFloat(tRaw);
                        if(timeVal > 10000000000) timeVal /= 1000; // MS fix
                    }

                    // Clean & Parse Prices (Remove commas inside quotes)
                    const cleanPrice = (val) => parseFloat(val.replace(/["',]/g, ''));
                    
                    const o = cleanPrice(parts[colMap.o]);
                    const h = cleanPrice(parts[colMap.h]);
                    const l = cleanPrice(parts[colMap.l]);
                    const c = cleanPrice(parts[colMap.c]);

                    if(!isNaN(timeVal) && !isNaN(c)) {
                        data.push({ time: timeVal, open: o, high: h, low: l, close: c });
                    }
                } catch(e) { }
            }
            
            return data.sort((a,b) => a.time - b.time);
        }

        // Helper: Guesses which column is which based on content
        static sniffRow(cols) {
            let t = -1, o = -1, h = -1, l = -1, c = -1;
            const numberCols = [];

            cols.forEach((col, idx) => {
                const clean = col.replace(/["',]/g, '').trim();
                
                // Is it a Date? (Contains - or / OR is a massive number > 1990)
                if(t === -1 && (clean.includes('-') || clean.includes('/') || (parseFloat(clean) > 900000000 && parseFloat(clean) < 2000000000))) {
                    t = idx;
                } 
                // Is it a Number?
                else if(!isNaN(parseFloat(clean))) {
                    numberCols.push(idx);
                }
            });

            // If we found a date and at least 4 numbers, assume OHLC order
            // Standard order is usually O, H, L, C
            if(t !== -1 && numberCols.length >= 4) {
                return { t: t, o: numberCols[0], h: numberCols[1], l: numberCols[2], c: numberCols[3] };
            }
            return null;
        }
    }

    // --- 2. UI LOGIC ---
    const chart = LightweightCharts.createChart(document.getElementById('chart'), {
        layout: { background: { color: '#000' }, textColor: '#888' },
        grid: { vertLines: { color: '#111' }, horzLines: { color: '#111' } },
        timeScale: { borderColor: '#333' }
    });
    
    const candleSeries = chart.addCandlestickSeries({ upColor: '#089981', downColor: '#f23645', borderVisible: false });
    const simSeries = chart.addCandlestickSeries({ upColor: '#00ffff', downColor: '#ff00ff', borderVisible: true, wickUpColor:'#00ffff', wickDownColor:'#ff00ff' });

    function log(msg, type='') {
        const div = document.createElement('div');
        div.innerText = "> " + msg;
        if(type==='err') div.className='log-err';
        document.getElementById('console').appendChild(div);
    }

    document.getElementById('fileInput').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if(!file) return;

        log(`Reading ${file.name}...`);
        const reader = new FileReader();
        
        reader.onload = (evt) => {
            try {
                // 1. PARSE
                const data = BlindParser.parse(evt.target.result);
                log(`Success: Found ${data.length} valid candles.`);
                log(`Date Range: ${new Date(data[0].time*1000).getFullYear()} - ${new Date(data[data.length-1].time*1000).getFullYear()}`);
                
                // 2. RENDER
                candleSeries.setData(data);
                chart.timeScale().fitContent();
                document.getElementById('watermark').style.display = 'none';

                // 3. AUTO-SIMULATE
                generateSim(data);

            } catch(err) {
                log("Error: " + err.message, 'err');
                log("Could not auto-detect columns. Check format.", 'err');
            }
        };
        reader.readAsText(file);
    });

    function generateSim(data) {
        log("Generating Future Projection...");
        // Simple Volatility Drift
        const last = data[data.length-1];
        let current = { ...last };
        const simData = [];
        const interval = data[1].time - data[0].time;
        
        // Calculate ATR-like volatility
        const lookback = data.slice(-20);
        let vol = 0;
        lookback.forEach(d => vol += (d.high - d.low));
        vol = vol / 20;

        for(let i=0; i<30; i++) {
            const drift = (Math.random() - 0.45) * vol; // Slight upward bias
            const open = current.close;
            const close = open + drift;
            const high = Math.max(open, close) + (Math.random() * vol * 0.5);
            const low = Math.min(open, close) - (Math.random() * vol * 0.5);
            
            const nextTime = current.time + interval;
            current = { time: nextTime, open, high, low, close };
            simData.push(current);
        }
        simSeries.setData(simData);
        log("Projection Complete (Cyan Candles).");
    }

    // Resize
    window.addEventListener('resize', () => {
        chart.applyOptions({ width: document.getElementById('chart').clientWidth, height: document.getElementById('chart').clientHeight });
    });
</script>
</body>
</html>
